<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      const PROMISE_STATUS_PENDING = "pending";
      const PROMISE_STATUS_FULFILLED = "fulfilled";
      const PROMISE_STATUS_REJECTED = "rejected";
      // 1. 定义类
      class MyPromise {
        result = 0;
        status = PROMISE_STATUS_PENDING;
        onFulfilledCallbacks = [];
        onRejectedCallbacks = [];
        constructor(exec) {
          // 定义两个不同状态下的存储数据方法
          // 箭头函数，保证this的指向
          const resolve = (value) => {
            if (this.status === PROMISE_STATUS_PENDING) {
              this.status = PROMISE_STATUS_FULFILLED;
              this.result = value;
              // 直接调用不对，因为此时还没有回调
              queueMicrotask(() => {
                this.onFulfilledCallbacks.forEach((cb) => {
                  cb(this.result);
                  console.log("-----");
                });
              });
            }
          };
          const reject = (reason) => {
            if (this.status === PROMISE_STATUS_PENDING) {
              this.status = PROMISE_STATUS_REJECTED;
              this.reason = reason;
              queueMicrotask(() => {
                onRejected(this.reason);
              });
            }
          };
          exec(resolve, reject);
        }
        // 2. 设计resolve存数据方法

        then(onFulfilled, onRejected) {
          return new MyPromise((resolve, reject) => {
            if (this.status === PROMISE_STATUS_PENDING) {
              this.onFulfilledCallbacks.push(onFulfilled);
              this.onRejectedCallbacks.push(onRejected);
            } else if (this.status === PROMISE_STATUS_FULFILLED) {
              resolve(onFulfilled(this.result));
            } else {
              reject(onRejected(this.reason));
            }
          });
        }
      }
      const p1 = new MyPromise((resolve, reject) => {
        resolve(1);
      });
      // console.log(p1.reason);
      p1.then((res) => {
        console.log("1", res);
        return 2;
      }).then((res) => {
        console.log(res);
      });
    </script>
  </body>
</html>
